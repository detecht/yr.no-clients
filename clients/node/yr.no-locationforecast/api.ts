/* tslint:disable */
/* eslint-disable */
/**
 * Locationforecast
 * Weather forecast for a specified place
 *
 * The version of the OpenAPI document: 2.0
 * Contact: weatherapi-adm@met.no
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Forecast
 */
export interface Forecast {
    /**
     * 
     * @type {ForecastMeta}
     * @memberof Forecast
     */
    'meta': ForecastMeta;
    /**
     * 
     * @type {Array<ForecastTimeStep>}
     * @memberof Forecast
     */
    'timeseries': Array<ForecastTimeStep>;
}
/**
 * 
 * @export
 * @interface ForecastMeta
 */
export interface ForecastMeta {
    /**
     * 
     * @type {ForecastUnits}
     * @memberof ForecastMeta
     */
    'units': ForecastUnits;
    /**
     * Update time for this forecast
     * @type {string}
     * @memberof ForecastMeta
     */
    'updated_at': string;
}
/**
 * Summary of weather conditions.
 * @export
 * @interface ForecastSummary
 */
export interface ForecastSummary {
    /**
     * 
     * @type {WeatherSymbol}
     * @memberof ForecastSummary
     */
    'symbol_code': WeatherSymbol;
}


/**
 * Weather parameters valid for a specific point in time.
 * @export
 * @interface ForecastTimeInstant
 */
export interface ForecastTimeInstant {
    /**
     * Air pressure at sea level
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'air_pressure_at_sea_level'?: number;
    /**
     * Air temperature
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'air_temperature'?: number;
    /**
     * Amount of sky covered by clouds.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'cloud_area_fraction'?: number;
    /**
     * Amount of sky covered by clouds at high elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'cloud_area_fraction_high'?: number;
    /**
     * Amount of sky covered by clouds at low elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'cloud_area_fraction_low'?: number;
    /**
     * Amount of sky covered by clouds at medium elevation.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'cloud_area_fraction_medium'?: number;
    /**
     * Dew point temperature at sea level
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'dew_point_temperature'?: number;
    /**
     * Amount of area covered by fog.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'fog_area_fraction'?: number;
    /**
     * Amount of humidity in the air.
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'relative_humidity'?: number;
    /**
     * The direction wind is coming from, in degrees clockwise from North
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'wind_from_direction'?: number;
    /**
     * Speed of wind
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'wind_speed'?: number;
    /**
     * Speed of wind gust
     * @type {number}
     * @memberof ForecastTimeInstant
     */
    'wind_speed_of_gust'?: number;
}
/**
 * Weather parameters valid for a specified time period.
 * @export
 * @interface ForecastTimePeriod
 */
export interface ForecastTimePeriod {
    /**
     * Maximum air temperature in period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'air_temperature_max'?: number;
    /**
     * Minimum air temperature in period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'air_temperature_min'?: number;
    /**
     * Best estimate for amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'precipitation_amount'?: number;
    /**
     * Maximum amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'precipitation_amount_max'?: number;
    /**
     * Minimum amount of precipitation for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'precipitation_amount_min'?: number;
    /**
     * Probability of any precipitation coming for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'probability_of_precipitation'?: number;
    /**
     * Probability of any thunder coming for this period
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'probability_of_thunder'?: number;
    /**
     * Maximum ultraviolet index if sky is clear
     * @type {number}
     * @memberof ForecastTimePeriod
     */
    'ultraviolet_index_clear_sky_max'?: number;
}
/**
 * 
 * @export
 * @interface ForecastTimeStep
 */
export interface ForecastTimeStep {
    /**
     * 
     * @type {ForecastTimeStepData}
     * @memberof ForecastTimeStep
     */
    'data': ForecastTimeStepData;
    /**
     * The time these forecast values are valid for. Timestamp in format YYYY-MM-DDThh:mm:ssZ (ISO 8601)
     * @type {string}
     * @memberof ForecastTimeStep
     */
    'time': string;
}
/**
 * Forecast for a specific time
 * @export
 * @interface ForecastTimeStepData
 */
export interface ForecastTimeStepData {
    /**
     * 
     * @type {ForecastTimeStepDataInstant}
     * @memberof ForecastTimeStepData
     */
    'instant': ForecastTimeStepDataInstant;
    /**
     * 
     * @type {ForecastTimeStepDataNext12Hours}
     * @memberof ForecastTimeStepData
     */
    'next_12_hours'?: ForecastTimeStepDataNext12Hours;
    /**
     * 
     * @type {ForecastTimeStepDataNext1Hours}
     * @memberof ForecastTimeStepData
     */
    'next_1_hours'?: ForecastTimeStepDataNext1Hours;
    /**
     * 
     * @type {ForecastTimeStepDataNext6Hours}
     * @memberof ForecastTimeStepData
     */
    'next_6_hours'?: ForecastTimeStepDataNext6Hours;
}
/**
 * Parameters which applies to this exact point in time
 * @export
 * @interface ForecastTimeStepDataInstant
 */
export interface ForecastTimeStepDataInstant {
    /**
     * 
     * @type {ForecastTimeInstant}
     * @memberof ForecastTimeStepDataInstant
     */
    'details'?: ForecastTimeInstant;
}
/**
 * Parameters with validity times over twelve hours. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext12Hours
 */
export interface ForecastTimeStepDataNext12Hours {
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext12Hours
     */
    'details': ForecastTimePeriod;
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext12Hours
     */
    'summary': ForecastSummary;
}
/**
 * Parameters with validity times over one hour. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext1Hours
 */
export interface ForecastTimeStepDataNext1Hours {
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext1Hours
     */
    'details': ForecastTimePeriod;
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext1Hours
     */
    'summary': ForecastSummary;
}
/**
 * Parameters with validity times over six hours. Will not exist for all time steps.
 * @export
 * @interface ForecastTimeStepDataNext6Hours
 */
export interface ForecastTimeStepDataNext6Hours {
    /**
     * 
     * @type {ForecastTimePeriod}
     * @memberof ForecastTimeStepDataNext6Hours
     */
    'details': ForecastTimePeriod;
    /**
     * 
     * @type {ForecastSummary}
     * @memberof ForecastTimeStepDataNext6Hours
     */
    'summary': ForecastSummary;
}
/**
 * 
 * @export
 * @interface ForecastUnits
 */
export interface ForecastUnits {
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'air_pressure_at_sea_level'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'air_temperature'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'air_temperature_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'air_temperature_min'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'cloud_area_fraction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'cloud_area_fraction_high'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'cloud_area_fraction_low'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'cloud_area_fraction_medium'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'dew_point_temperature'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'fog_area_fraction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'precipitation_amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'precipitation_amount_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'precipitation_amount_min'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'probability_of_precipitation'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'probability_of_thunder'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'relative_humidity'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'ultraviolet_index_clear_sky_max'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'wind_from_direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'wind_speed'?: string;
    /**
     * 
     * @type {string}
     * @memberof ForecastUnits
     */
    'wind_speed_of_gust'?: string;
}
/**
 * 
 * @export
 * @interface METJSONForecast
 */
export interface METJSONForecast {
    /**
     * 
     * @type {PointGeometry}
     * @memberof METJSONForecast
     */
    'geometry': PointGeometry;
    /**
     * 
     * @type {Forecast}
     * @memberof METJSONForecast
     */
    'properties': Forecast;
    /**
     * 
     * @type {string}
     * @memberof METJSONForecast
     */
    'type': METJSONForecastTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum METJSONForecastTypeEnum {
    Feature = 'Feature'
}

/**
 * 
 * @export
 * @interface PointGeometry
 */
export interface PointGeometry {
    /**
     * [longitude, latitude, altitude]. All numbers in decimal.
     * @type {Array<number>}
     * @memberof PointGeometry
     */
    'coordinates': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PointGeometry
     */
    'type': PointGeometryTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PointGeometryTypeEnum {
    Point = 'Point'
}

/**
 * A identifier that sums up the weather condition for this time period, see documentation.
 * @export
 * @interface WeatherSymbol
 */
export interface WeatherSymbol {
    [key: string]: any;

}

/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {ClassicFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet: async (lat: number, lon: number, format: ClassicFormatGetFormatEnum, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('classicFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('classicFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('classicFormatGet', 'format', format)
            const localVarPath = `/classic.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet: async (lat: number, lon: number, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('classicGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('classicGet', 'lon', lon)
            const localVarPath = `/classic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompactFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet: async (lat: number, lon: number, format: CompactFormatGetFormatEnum, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('compactFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('compactFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('compactFormatGet', 'format', format)
            const localVarPath = `/compact.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet: async (lat: number, lon: number, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('compactGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('compactGet', 'lon', lon)
            const localVarPath = `/compact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompleteFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet: async (lat: number, lon: number, format: CompleteFormatGetFormatEnum, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('completeFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('completeFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('completeFormatGet', 'format', format)
            const localVarPath = `/complete.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet: async (lat: number, lon: number, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('completeGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('completeGet', 'lon', lon)
            const localVarPath = `/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {MiniFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miniFormatGet: async (lat: number, lon: number, format: MiniFormatGetFormatEnum, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('miniFormatGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('miniFormatGet', 'lon', lon)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('miniFormatGet', 'format', format)
            const localVarPath = `/mini.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miniGet: async (lat: number, lon: number, altitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('miniGet', 'lat', lat)
            // verify required parameter 'lon' is not null or undefined
            assertParamExists('miniGet', 'lon', lon)
            const localVarPath = `/mini`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (altitude !== undefined) {
                localVarQueryParameter['altitude'] = altitude;
            }

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lon !== undefined) {
                localVarQueryParameter['lon'] = lon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {StatusFormatGetFormatEnum} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet: async (format: StatusFormatGetFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('statusFormatGet', 'format', format)
            const localVarPath = `/status.{format}`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration)
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {ClassicFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classicFormatGet(lat: number, lon: number, format: ClassicFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classicFormatGet(lat, lon, format, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.classicFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classicGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classicGet(lat, lon, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.classicGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompactFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compactFormatGet(lat: number, lon: number, format: CompactFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compactFormatGet(lat, lon, format, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.compactFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compactGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compactGet(lat, lon, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.compactGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompleteFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeFormatGet(lat: number, lon: number, format: CompleteFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeFormatGet(lat, lon, format, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.completeFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeGet(lat, lon, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.completeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {MiniFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miniFormatGet(lat: number, lon: number, format: MiniFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miniFormatGet(lat, lon, format, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.miniFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async miniGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<METJSONForecast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.miniGet(lat, lon, altitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.miniGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {StatusFormatGetFormatEnum} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusFormatGet(format: StatusFormatGetFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusFormatGet(format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.statusFormatGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataApi.statusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataApiFp(configuration)
    return {
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {ClassicFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicFormatGet(lat: number, lon: number, format: ClassicFormatGetFormatEnum, altitude?: number, options?: any): AxiosPromise<string> {
            return localVarFp.classicFormatGet(lat, lon, format, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classicGet(lat: number, lon: number, altitude?: number, options?: any): AxiosPromise<string> {
            return localVarFp.classicGet(lat, lon, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompactFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactFormatGet(lat: number, lon: number, format: CompactFormatGetFormatEnum, altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.compactFormatGet(lat, lon, format, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactGet(lat: number, lon: number, altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.compactGet(lat, lon, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {CompleteFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeFormatGet(lat: number, lon: number, format: CompleteFormatGetFormatEnum, altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.completeFormatGet(lat, lon, format, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeGet(lat: number, lon: number, altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.completeGet(lat, lon, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {MiniFormatGetFormatEnum} format format code (file extension)
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miniFormatGet(lat: number, lon: number, format: MiniFormatGetFormatEnum, altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.miniFormatGet(lat, lon, format, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {number} lat Latitude
         * @param {number} lon Longitude
         * @param {number} [altitude] Whole meters above sea level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        miniGet(lat: number, lon: number, altitude?: number, options?: any): AxiosPromise<METJSONForecast> {
            return localVarFp.miniGet(lat, lon, altitude, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {StatusFormatGetFormatEnum} format format code (file extension)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusFormatGet(format: StatusFormatGetFormatEnum, options?: any): AxiosPromise<string> {
            return localVarFp.statusFormatGet(format, options).then((request) => request(axios, basePath));
        },
        /**
         * Weather forecast for a specified place
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: any): AxiosPromise<string> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {ClassicFormatGetFormatEnum} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public classicFormatGet(lat: number, lon: number, format: ClassicFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).classicFormatGet(lat, lon, format, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public classicGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).classicGet(lat, lon, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {CompactFormatGetFormatEnum} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public compactFormatGet(lat: number, lon: number, format: CompactFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).compactFormatGet(lat, lon, format, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public compactGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).compactGet(lat, lon, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {CompleteFormatGetFormatEnum} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public completeFormatGet(lat: number, lon: number, format: CompleteFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).completeFormatGet(lat, lon, format, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public completeGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).completeGet(lat, lon, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {MiniFormatGetFormatEnum} format format code (file extension)
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public miniFormatGet(lat: number, lon: number, format: MiniFormatGetFormatEnum, altitude?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).miniFormatGet(lat, lon, format, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {number} lat Latitude
     * @param {number} lon Longitude
     * @param {number} [altitude] Whole meters above sea level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public miniGet(lat: number, lon: number, altitude?: number, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).miniGet(lat, lon, altitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {StatusFormatGetFormatEnum} format format code (file extension)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public statusFormatGet(format: StatusFormatGetFormatEnum, options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).statusFormatGet(format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Weather forecast for a specified place
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    public statusGet(options?: RawAxiosRequestConfig) {
        return DataApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ClassicFormatGetFormatEnum {
    Xml = 'xml'
}
/**
  * @export
  * @enum {string}
  */
export enum CompactFormatGetFormatEnum {
    Json = 'json'
}
/**
  * @export
  * @enum {string}
  */
export enum CompleteFormatGetFormatEnum {
    Json = 'json'
}
/**
  * @export
  * @enum {string}
  */
export enum MiniFormatGetFormatEnum {
    Json = 'json'
}
/**
  * @export
  * @enum {string}
  */
export enum StatusFormatGetFormatEnum {
    Json = 'json'
}


/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * RSS feed of changes to this product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changelogGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/changelog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * RSS feed of changes to this product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changelogGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changelogGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.changelogGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthzGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthzGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.healthzGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.schemaGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * RSS feed of changes to this product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changelogGet(options?: any): AxiosPromise<void> {
            return localVarFp.changelogGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Check health status for product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthzGet(options?: any): AxiosPromise<void> {
            return localVarFp.healthzGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Schema for XML data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaGet(options?: any): AxiosPromise<void> {
            return localVarFp.schemaGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * RSS feed of changes to this product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public changelogGet(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).changelogGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check health status for product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public healthzGet(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).healthzGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schema for XML data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public schemaGet(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).schemaGet(options).then((request) => request(this.axios, this.basePath));
    }
}



